Tutorial: lfs-mini-pm.sh — Gerenciador simples de build/empacotamento
====================================================================

Este documento explica como instalar, configurar e usar o script lfs-mini-pm.sh.  
Ele é um gerenciador mínimo de pacotes, pensado para Linux From Scratch (LFS), sem gestão automática de dependências.

--------------------------------------------------------------------
1. Instalação
--------------------------------------------------------------------

1. Baixe o script `lfs-mini-pm.sh` e dê permissão de execução:
   chmod +x lfs-mini-pm.sh

2. Opcionalmente, copie para o PATH:
   sudo cp lfs-mini-pm.sh /usr/local/bin/lfs-mini-pm

--------------------------------------------------------------------
2. Estrutura de diretórios
--------------------------------------------------------------------

O script usa variáveis (todas configuráveis via flags ou ambiente):

ROOT_DIR   = diretório base (padrão: cwd)
SOURCE     = $ROOT_DIR/sources    (arquivos baixados)
WORKDIR    = $ROOT_DIR/work       (fontes extraídos)
BUILD      = $ROOT_DIR/build      (diretório de build separado)
DESTBASE   = $ROOT_DIR/dest       (instalação com DESTDIR)
PKGDIR     = $ROOT_DIR/packages   (pacotes gerados)
LOGDIR     = $ROOT_DIR/logs       (logs de build)
RECIPES    = $ROOT_DIR/recipes    (receitas)
REGISTRY   = $ROOT_DIR/registry.txt

Para criar a estrutura:
   ./lfs-mini-pm.sh init

--------------------------------------------------------------------
3. Comandos disponíveis
--------------------------------------------------------------------

init
    Cria a árvore de diretórios e o arquivo de registro.

new NAME VERSION URL [SHA256]
    Cria um recipe mínimo para o pacote.

fetch NAME
    Baixa o código-fonte (via curl ou git).

extract NAME
    Extrai/descompacta o source para $WORKDIR.

build NAME
    Baixa, extrai, aplica patches (se houver), compila, instala em DESTDIR + fakeroot e gera pacote.

info NAME
    Mostra informações básicas da receita.

list
    Lista todas as receitas disponíveis.

search PATTERN
    Procura receitas pelo nome.

installpkg ARQUIVO.tar.*
    Instala pacote diretamente no / (extrai via fakeroot).

clean NAME|all
    Remove diretórios temporários de build/trabalho.

--------------------------------------------------------------------
4. Flags curtas (opções)
--------------------------------------------------------------------

-s DIR   SOURCE
-w DIR   WORKDIR
-b DIR   BUILD
-d DIR   DEST base
-p DIR   PKGDIR
-L DIR   LOGDIR
-r DIR   RECIPES
-R FILE  REGISTRY
-j N     JOBS (número de threads)
-C MODE  COLOR: auto|always|never
-q       quiet
-v       verbose
-S       desativa spinner
-h       ajuda

Exemplo:
   ./lfs-mini-pm.sh -r ./meus_recipes -p ./pkgs build zlib

--------------------------------------------------------------------
5. Estrutura de um recipe
--------------------------------------------------------------------

Um recipe é um arquivo `recipes/NOME.recipe` em shell POSIX.  
Exemplo genérico:

NAME=zlib
VERSION=1.3
URL="https://zlib.net/zlib-$VERSION.tar.gz"
SHA256="9a93d4135d39df2d4f4f2d6a5a3b8e93d53c8e4f21a01fda7e2d0f15e5e5d5a1"
DEPENDS=""

PREFIX=${PREFIX:-/usr}

configure() {
    ./configure --prefix="$PREFIX"
}

build() {
    make -j${JOBS}
}

install() {
    make DESTDIR="$DESTDIR" install
}

Funções suportadas:
    configure() → configura o build
    build()     → compila
    install()   → instala no DESTDIR

Variáveis reconhecidas:
    NAME, VERSION, URL ou GIT, SHA256, DEPENDS, PREFIX

--------------------------------------------------------------------
6. Patches
--------------------------------------------------------------------

Se houver diretório `recipes/NOME.patches/` contendo arquivos *.patch,  
o script aplica automaticamente antes da configuração.

Exemplo:
    recipes/glibc.recipe
    recipes/glibc.patches/0001-fix-bug.patch
    recipes/glibc.patches/0002-another-fix.patch

--------------------------------------------------------------------
7. Exemplo: Recipe do glibc
--------------------------------------------------------------------

Arquivo: recipes/glibc.recipe

NAME=glibc
VERSION=2.39
URL="https://ftp.gnu.org/gnu/libc/glibc-$VERSION.tar.xz"
SHA256="4b6b40738183b081e0b6626900b8f359bd2d96ff47568cf81277849e6df63b44"

DEPENDS="linux-headers"

PREFIX=${PREFIX:-/usr}

configure() {
    mkdir -p build
    cd build
    ../configure \
        --prefix=$PREFIX \
        --disable-werror \
        --enable-kernel=4.4 \
        --enable-stack-protector=strong \
        libc_cv_slibdir=/lib
}

build() {
    cd build
    make -j${JOBS}
}

install() {
    cd build
    make DESTDIR="$DESTDIR" install
}

Para aplicar patch, basta colocar arquivos em recipes/glibc.patches/.

--------------------------------------------------------------------
8. Fluxo de uso típico
--------------------------------------------------------------------

# criar estrutura inicial
./lfs-mini-pm.sh init

# criar recipe (exemplo: zlib)
./lfs-mini-pm.sh new zlib 1.3 "https://zlib.net/zlib-1.3.tar.gz"

# editar recipe para ajustar opções

# compilar e gerar pacote
./lfs-mini-pm.sh build zlib

# ver infos do pacote
./lfs-mini-pm.sh info zlib

# instalar pacote
sudo ./lfs-mini-pm.sh installpkg packages/zlib-1.3.tar.gz

--------------------------------------------------------------------
9. Registro
--------------------------------------------------------------------

Todos os pacotes gerados são registrados em registry.txt no formato:

NAME    VERSION    ARQUIVO_PACOTE   TIMESTAMP

--------------------------------------------------------------------
10. Conclusão
--------------------------------------------------------------------

O lfs-mini-pm.sh é um gerenciador mínimo:
 - Não resolve dependências automaticamente.
 - Usa apenas ferramentas comuns (sh, curl, tar, fakeroot).
 - Automatiza o ciclo fetch → extract → build → install → package.

Ideal para estudos, LFS e sistemas minimalistas.

FIM DO TUTORIAL
